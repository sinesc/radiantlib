/*
 * radiant 2d webgl rendering engine
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var mat4 = require('gl-matrix.js').mat4;

module Renderer = proto {

    radiant: null,

    /**
     * @var integer maximum number of rectangles that can be drawn in one run
     */
    maxSize: 65536 / 4,

    /**
     * @var integer current number of rectangles
     */
    size: 0,

    /**
     * @var Float32Array vertices, 4 per rectangle
     */
    vertices: null,
    vertexIntView: null,
    vertexBuffer: null,

    /**
     * indices into the vertex data, 6 per rectangle (indexes 2 duplicate vertices where the triangles meet)
     */
    indices: null,
    indexBuffer: null,

    /**
     * the shader and shader-instance used for the rendering
     */
    Shader: null,
    shader: null,

    currentBlendMode: null,
    currentTexture: null,

    textureUnit: 0,

    /**
     * increased for each webgl draw call
     */
    debugDrawCount: 0,

    /**
     * creates a new renderer
     *
     * @param Radiant radiant
     */
    constructor: func(object radiant) {

        this.radiant = radiant;
        this.shader = new this.Shader(radiant);

        // set up vertex-indices for each rectangle

        var numVertices = this.maxSize * 4;
        this.vertices = new Float32Array(numVertices * this.shader.attributeSize / 4);
        this.vertexIntView = new Uint32Array(this.vertices.buffer);
        this.vertexBuffer = null;

        var numIndices = this.maxSize * 6;
        this.indices = new Uint16Array(numIndices);
        this.indexBuffer = null;

        // create 6 indices per rectangle (3 per triangle, vertices 0 and 2 are shared between triangles)

        for (var index = 0, vertex = 0; index < numIndices; index += 6/*, vertex += 4*/) {
            this.indices[index + 0] = vertex + 0;
            this.indices[index + 1] = vertex + 1;
            this.indices[index + 2] = vertex + 2;
            this.indices[index + 3] = vertex + 0;
            this.indices[index + 4] = vertex + 2;
            this.indices[index + 5] = vertex + 3;
            vertex += 4;
        }

        this.restoreContext();
        this.setupUniforms();

        this.radiant.on('contextrestored', this, this.restoreContext);
        this.radiant.on('resize', this, this.setupUniforms);
    },

    destroy: func() {

        this.radiant.off('contextrestored', this, this.restoreContext);
        this.radiant.off('resize', this, this.setupUniforms);
        this.shader.destroy();

        var gl = this.radiant.gl;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);
    },

    /**
     * restore webgl context after context loss
     */
    restoreContext: func() {

        var gl = this.radiant.gl;

        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);
    },

    /**
     * set up base matrix
     */
    setupUniforms: func() {

        var matrix = mat4.create();
        mat4.identity(matrix);
        mat4.translate(matrix, matrix, [ -1.0, 1.0, 0.0 ]);
        mat4.scale(matrix, matrix, [ 2.0 / this.radiant.width, -2.0 / this.radiant.height, 1.0 ]);

        this.shader.uMatrix.value = matrix;
        this.shader.uSampler.value = this.textureUnit;
    },

    /**
     * draw previous added rectangles and reset list
     */
    draw: func() {

        if (this.size === 0) {
            return;
        }

        var gl = this.radiant.gl;

        // select gl buffers, copy array data

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        var view = this.vertices.subarray(0, this.size * this.shader.attributeSize);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        // bind texture

        this.currentTexture.use(this.textureUnit);

        // assign uniforms and attributes

        if (this.radiant.currentShader !== this.shader) {
            this.shader.use();
        }

        // draw 2 triangles = 6 indices / 4 unique vertices per rectangle

        gl.drawElements(gl.TRIANGLES, this.size * 6, gl.UNSIGNED_SHORT, 0);

        this.size = 0;
        this.debugDrawCount++;
    },

    /**
     * set up drawing state for given texture and current blendmode
     *
     * @param Texture texure
     */
    setupState: func(object texture) {

        if (this.currentTexture === null) {
            this.currentTexture = texture;
        }

        if (this.currentBlendMode === null) {
            this.currentBlendMode = this.radiant.blendMode;
        }

        if (this.radiant.blendMode !== this.currentBlendMode || texture !== this.currentTexture) {

            // temporarily restore previous blend-mode and texture to draw old buffer before starting new

            var newBlend = this.radiant.blendMode;
            this.radiant.blendMode = this.currentBlendMode;

            this.draw();

            this.currentBlendMode = newBlend;
            this.currentTexture = texture;
            this.radiant.blendMode = newBlend;
        }
    },

};
