/*
 * radiant 2d webgl rendering engine
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Uniform = require('./uniform');
var Attribute = require('./attribute');

module Shader = proto {

    radiant: null,

    fragmentSrc: '',
    vertexSrc: '',

    /**
     * @var actual gl shader program
     */
    program: null,

    /**
     * @var Array registered <Attribute>s
     */
    attributes: null,

    /**
     * @var Array registered <Uniform>s
     */
    uniforms: null,

    /**
     * @var boolean true after a uniform was changed until change was propagated to gl
     */
    uniformUpdateRequired: false,

    /**
     * @var finite total attributes size in bytes
     */
    attributeSize: 0,

    /**
     * construct new shader
     *
     * @param Radiant radiant
     */
    constructor: func(radiant) {

        this.radiant = radiant;
        this.attributes = [];
        this.uniforms = [];
        this.compile();
        this.register();
        this.radiant.on('contextrestored', this, this.restoreContext);
    },

    /**
     * destroy shader and release resources
     */
    destroy: func() {

        this.radiant.off('contextrestored', this, this.restoreContext);
        this.radiant = null;
        this.attributes = null;
        this.uniforms = null;
        this.radiant.gl.deleteProgram(this.program);
    },

    /**
     * register attributes and uniforms here
     */
    register: func() { },

    /**
     * generate shader (compile it, associate uniforms and attributes)
     */
    restoreContext: func() {

        var gl = this.radiant.gl;
        var attributes = this.attributes;
        var uniforms = this.uniforms;

        this.compile();
        gl.useProgram(this.program);

        for (var i = 0, num = attributes.length; i < num; ++i) {
            attributes[i].restoreContext();
        }

        for (var i = 0, num = uniforms.length; i < num; ++i) {
            uniforms[i].restoreContext();
        }

        if (this.radiant.currentShader !== null) {
            gl.useProgram(this.radiant.currentShader.program);
        }
    },

    /**
     * registers a shader attribute with this wrapper
     *
     * @param string srcName name in shader source
     * @param integer parts
     * @param integer type GL type
     * @param boolean normalized
     * @param string propName name of the object property on this object that will refer to srcName
     */
    registerAttribute: func(string srcName, finite parts, finite type, boolean normalized = false, string propName = srcName) {

        var attribute = new Attribute(this, srcName, parts, type, normalized);
        this[propName] = attribute;
        this.attributes.push(attribute);
        this.attributeSize += attribute.size;
    },

    /**
     * use vertex attribute pointers from this shader
     */
    useAttributes: func() {

        var attributes = this.attributes;
        var offset = 0;
        var size = this.attributeSize;

        for (var i = 0, num = attributes.length; i < num; ++i) {
            var attribute = attributes[i];
            offset += attribute.use(size, offset);
        }
    },

    /**
     * registers a shader uniform with this wrapper
     *
     * @param string srcName name in shader source
     * @param string propName name of the object property on this object that will refer to srcName
     */
    registerUniform: func(string srcName, finite parts = 1, boolean isMatrix = false, boolean isFloat = isMatrix, string propName = srcName) {

        var uniform = new Uniform(this, srcName, parts, isMatrix, isFloat);
        this[propName] = uniform;
        this.uniforms.push(uniform);
    },

    /**
     * set uniforms for this shader
     */
    useUniforms: func() {

        var uniforms = this.uniforms;

        for (var i = 0, num = uniforms.length; i < num; ++i) {
            uniforms[i].use();
        }
    },

    /**
     * use this shader programm
     */
    use: func() {

        var gl = this.radiant.gl;

        gl.useProgram(this.program);
        this.useAttributes();

        // uniformUpdateRequired is set by individual uniforms

        if (this.uniformUpdateRequired) {
            this.useUniforms();
            this.uniformUpdateRequired = false;
        }
    },

    /**
     * compile vertex and fragment source to program
     */
    compile: func() {

        var gl = this.radiant.gl;

        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, Private->createShader(gl.VERTEX_SHADER, this.vertexSrc));
        gl.attachShader(shaderProgram, Private->createShader(gl.FRAGMENT_SHADER, this.fragmentSrc));
        gl.linkProgram(shaderProgram);

        if (gl.isContextLost() === false && gl.getProgramParameter(shaderProgram, gl.LINK_STATUS) !== true) {
            throw new Exception('Error linking shaders');
        }

        this.program = shaderProgram;
    },
};

var Private = proto {

    createShader: func(finite type, string src) {

        var gl = this.radiant.gl;

        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);

        if (gl.isContextLost() === false && gl.getShaderParameter(shader, gl.COMPILE_STATUS) !== true) {
            throw new Exception('Error compiling ' + (type === gl.VERTEX_SHADER ? 'vertex' : 'fragment') + '-shader');
        }

        return shader;
    },
};
