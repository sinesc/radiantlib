/*
 * radiant 2d webgl rendering engine
 * Copyright (C) 2014 Dennis MÃ¶hlmann <mail@dennismoehlmann.de>
 * Licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var Listenable = require('astd/listenable');
var Texture = require('./texture');

/**
 * individual sprite
 *
 * @event load()
 */
module Sprite = proto (Listenable) {

    radiant: null,

    /**
     * image object
     */
    texture: null,

    /**
     * array of frame coordinates for the loaded sprite
     */
    frames: null,

    /**
     * set to true once the sprite is ready
     */
    ready: false,

    /**
     * @var integer width of the sprite
     */
    width: 0,

    /**
     * @var integer height of the sprite
     */
    height: 0,

    /**
     * @var integer x anchor position
     */
    anchorX: 0,

    /**
     * @var integer y anchor position
     */
    anchorY: 0,

    /**
     * construct sprite from filename or parameter object
     *
     * @param string/Parameter params
     */
    constructor: func(object radiant, params) {

        this.radiant = radiant;
        this.frames = [];

        if (typeof params === 'string') {
            params = new Parameter(params);
        }

        // load image

        var that = this;
        var image = document.createElement('img');
        image.src = params.file;

        image.addEventListener('load', func listener() {
            image.removeEventListener('load', listener);
            that.generate(image, params);
        });
    },

    /**
     * @var finite anchor u position (0..1 is inside the sprite)
     */
    anchorU: prop {
        get: func() {
            return this.anchorX / this.width;
        },
        set: func(value) {
            this.anchorX = value * this.width;
        }
    },

    /**
     * @var finite anchor v position (0..1 is inside the sprite)
     */
    anchorV: prop {
        get: func() {
            return this.anchorY / this.height;
        },
        set: func(value) {
            this.anchorY = value * this.height;
        }
    },

    /**
     * called by constructor once the sprite's image is loaded, computes sprite frames
     *
     * @param Image image
     * @param Parameter params
     */
    generate: func(object image, Parameter params) {

        // create texture

        this.texture = new Texture(this.radiant, image);

        // try layout auto-detection

        var layout = params.layout;

        if (layout === Parameter::LAYOUT_AUTO) {
            layout = (params.width * params.count === this.texture.width ? Parameter::LAYOUT_HORIZONTAL : Parameter::LAYOUT_VERTICAL);
        } else {
            layout = params.layout;
        }

        // compute frames

        this.width = params.width;
        this.height = params.height;
        this.anchorU = params.anchorU;
        this.anchorV = params.anchorV;

        for (var id = params.start, end = params.start + params.count; id < end; id++) {
            this.frames.push(getFrame(layout, this.texture, params.width, params.height, id));
        }

        this.ready = true;
        this.execute('load');
    }
};

/**
 * calculates the coordinates for a specific frame using given layout
 *
 * @param string layout horizontal (ids count left to right, top to bottom) or vertical (ids count top to bottom, left to right)
 * @param object texture
 * @param finite spriteWidth width for individual sprite frames
 * @param finite spriteHeight height for individual sprite frames
 * @param finite id frame id
 */
var getFrame = func(string layout, object texture, finite spriteWidth, finite spriteHeight, finite id) {

    // calculate x and y for given frame using defined layout order

    var spl, x, y;

    if (layout === Parameter::LAYOUT_HORIZONTAL) {
        spl = texture.width / spriteWidth;
        x = Math.floor(id % spl) * spriteWidth;
        y = Math.floor(id / spl) * spriteHeight;
    } else {
        spl = texture.height / spriteHeight;
        x = Math.floor(id / spl) * spriteWidth;
        y = Math.floor(id % spl) * spriteHeight;
    }

    return new Frame(texture, x, y, spriteWidth, spriteHeight);
};

/**
 * describes a frame's u/v position within the sprite's texture
 */
export Frame = proto {

    u0      : 0.0,
    u1      : 0.0,
    v0      : 0.0,
    v1      : 0.0,

    constructor: func(object texture, finite x, finite y, finite width, finite height) {

        var uv0 = texture.getUV(x, y);
        var uv1 = texture.getUV(x + width, y + height);

        this.u0 = uv0[0];
        this.u1 = uv1[0];
        this.v0 = uv0[1];
        this.v1 = uv1[1];
    },
};

/**
 * describes sprite construction properties
 */
export Parameter = proto {

    /**
     * frame layout types
     */
    LAYOUT_AUTO         : 'auto',
    LAYOUT_HORIZONTAL   : 'horizontal',
    LAYOUT_VERTICAL     : 'vertical',

    file    : '',
    width   : -1,
    height  : -1,
    anchorU : 0.5,
    anchorV : 0.5,
    start   : 0,
    count   : 1,
    layout  : 'vertical',

    constructor: func(string? file = null) {

        if (file === null) {
            return;
        }

        this.file = file;

        var match = file.match(/_([0-9]+)x([0-9]+)x([0-9]+)\./);

        if (match !== null) {
            this.width = parseInt(match[1]);
            this.height = parseInt(match[2]);
            this.count = parseInt(match[3]);
            this.layout = Parameter::LAYOUT_AUTO;
        }
    },
};
